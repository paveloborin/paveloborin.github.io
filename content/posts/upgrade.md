---
title: "Один опыт выкатывания большой фичи"
date: 2018-06-09T09:54:57+05:00
draft: false
tags: ["о разработке"]
---

### Вступление

В статье я хочу поделиться своим опытом выкатывания "большой фичи", которую можно рассматривать как апгрейд сложной системы, и уроками, которые мне удалось извлечь из этого опыта.

Статья состоит из трех частей и заключения. В первой я рассказываю о типах развития программных продуктов и о том, насколько важны апгрейды в жизненном цикле систем для сохранения их конкурентоспособности. Во второй описаны мои размышления о непосредственной роли разработчика в развитии программных систем. В третьей я предлагаю свой подход к минимизации рисков при апгрейде систем, который основан на правильной архитектуре, использовании переключателей для плавного выкатывания фичи на продакшен и хорошо развитых горизонтальных связях разработчика с нужными людьми в компании.

### О типах развития программных систем и апгрейде как одной из разновидностей

*О развитии систем - Типы развития систем - Апгрейд*

Мне нравится рассматривать время абстрактно как неотъемлемую часть некоего дифференциального уравнения описывающего эволюцию. Со временем все системы развиваются либо отмирают - так действует эволюция. Говоря о развитии, я имею в виду развитие программных продуктов и непосредственно разработку ПО.

Мы привыкли думать о развитии как о постепенном процессе, но в реальности развитие чаще всего происходит иначе. Это явление широко описано в литературе как эффект «плато». Такое развитие обычно выглядит как отсутствие роста или очень плавный рост - плато, за которым следует скачок на качественно новый уровень и затем снова плато. 

<span style="display:block;text-align:center">
<img src="/static/plato1.png" width="450px">
<br>Рис. 1 Иллюстрация эффекта плато
</span>

В развитии ПО эффект плато обусловлен тем, что у каждой программной системы есть свой диапазон нагрузки, под который она спроектирована работать. 
В реальности правило "работает не трогай" работает (прошу прощение за тавтологию) и никто не будет/не даст перерабатывать систему без острой на то необходимости. 
Особенно если от стабильной работы системы напрямую зависит прибыль компании. 
Обычно на любые сколько-нибудь существенные изменения решаются только когда текущая нагрузка подходит уже близко к верхней границе изначально заложенного при проектировании системы диапазона. 
Из-за чего часто временные рамки, за которые система должны перескочить с одного уровня на другой, бывают ограничены очень небольшим отрезком времени. 
Развитие типа “плато” далее я буду называть **апгрейдом системы**.

Между тем мы знаем разные варианты развития систем. Например, развитие через постепенное улучшение и приращение, создание "лучшей версии" системы через полное переписывание и гибридный подход, основанный на комбинации первых двух.

**Подход обновления системы через постепенное приращение** функционала и улучшение системы с помощью рефакторинга («оставь поляну после себя чище» - говаривал дядюшка Боб) является самым популярным, но не всегда подходит. Так, никакой рефакторинг на самом деле не поможет перевести систему, спроектированную на небольшую нагрузку, под хайлоад. 

Главными же минусами **подхода с полным переписывания системы** являются: время и постоянной отставание новой версии от "мастер" версии. Процесс может затянуться в разы по сравнению с изначально заложенными сроками и как следствие - не застрахованность от возможности провала. Отставание заключается в рассинхронизованности новой версии и текущей системы, в которую постоянно добавляется новый функционал. Не так редки и случаи, когда переписанная система оказывается хуже изначальной. Победителей не судят, но опыт показывает что, если из-за “непонятно для чего нужного” переписывания компания понесла убытки, то скорее всего разработчику будет не так легко оправдаться.

В **гибридном подходе** только часть системы развивается скачками, а остальная часть развивается постепенно. Это постоянный апгрейд системы по частям новыми более "крутыми" компонентами. 

Часто апгрейд системы является единственно верным вариантом. Какому бы типу развития вашей системы вы не отдали предпочтение, вам не удастся избежать апгрейда, если вы хотите чтобы система оставалась конкурентоспособной. Постоянное приращение функционала системы возможно только до тех пор пока не наступает некий критический момент перехода количества в качество. И тут без коренных преобразований - скачка на качественно новый уровень никак не обойтись. (Описываемый нами скачок можно так же рассматривать как трансформацию множества количественных изменений в новое качество.) 

Апгрейд скрывает под собой зачастую "завоз" новых технологий или переписывание большого куска системы. Обычно на презентациях докладчиков IT конференций апгрейды - это те ключевые моменты, которые докладчики упоминают при показе временной шкалы развития своих систем. Также стоит заменить, что скорость изменения большинства систем от рождения до зрелости напоминает чем то график логарифма. Чем дольше живет система тем таких преобразований становится меньше в единицу времени.

<span style="display:block;text-align:center">
<img src="/static/lg.png" width="500px">
<br>Рис. 2 График логарифма
</span>

Давайте попробуем дать некоторую характеристику того, что такое большая задача и отличия ее от небольшой. Признаки большой задачи:

1. Кол-во часов - месяц и более разработки;

2. Наличие кросскомандной разработки;

3. Большая нагрузка на систему;

4. Возможные серьезные репутационные и финансовые потери в случае багов;

5. Сложность систем;

6. Интеграция нескольких систем друг с другом;

7. Высокая степень "завязанности" на другие отделы. Другие разработчики, менеджеры, необходимость состыковки параллельно разрабатываемых подсистем, сложность тестирования, админы, лайфтим, безопасники, документация, воздействие на конечного потребителя, служба саппорта - все это внешние зависимости, которые придется учитывать разработчику, если он действительно хочет выкатить фичу в срок. И все это для разработчика может перерасти, как говорится в одной игре, в “войну, которая никогда не кончается”.

Апгрейд системы - это всегда большая задача, но обратное не всегда верно. 

### О роли разработчика в развитии системы

*О психологии разработчиков - О внешних зависимостях и кросс-командной разработке*

Большинство разработчиков оптимисты. 

Скажем прямо, часто разработчики переоценивают свои возможности, считая что способны реализовать любую задачу, используя лишь собственные силы, и подсознательно не учитывают при этом внешние факторы, от которых зависит любая задача. Встречи, согласования, "работа ногами" - это все неотъемлемые части разработки, на которые на самом то деле порой тратиться две трети рабочего дня.

Никто не любит кросс-командную разработку. Разработчики предпочитают рассчитывать на себя и членов своей команды и по максимуму избегать внешних зависимостей. Для этого у них есть свои объективные причины, начиная с того, что производительность одного человека в команде из одного-трех разработчиков будет всегда выше, чем производительность в команде из 10 человек, и заканчивая боязнью погрязнуть в бесконечных митингах и перебрасывании ответственности между друг другом. 

Взять ответственность за все и довести начатое до конца на самом деле бывает проще, чем распределить эту ответственность на 10 человек. Когда лично никто ни за что не ответственен и каждый завязан на соседа, то непростительно много сил тратится на управлением этим зоопарком, в то время как продвижение задачи вперед идет медленными темпами. Также нелюбви к внешним взаимодействиям способствует и то, что большинство "внешних" людей зачастую мало заинтересованы в вашей задаче, не понимают значимость того или иного тикета и на что он влияет. 

Все это приводит к тому, что у разработчика в случае такой задачи как апгрейд системы может появиться желание **выкатить что-то "без широкой огласки"**, чтобы ничто не встало на его пути. Так как любая публичность всегда может превратиться в тормоз, рискующий навеки похоронить все благие начинания. 

Публичность задачи подразумевает усиление контроля. Контроль полезен, когда **контроль - это оказание помощи**. Например, помощи в планировании, декомпозиции задачи и тп. Постоянные митинги планирования, обсуждения выглядят красиво в основном только в книгах, в жизни это чаще всего не оказывает никакой помощи, к сожалению. 

Сделать "по тихому" - это на самом-то деле непрофессионально и плохо. Допустим у нас есть система в состоянии A, из которого нужно прийти в B, есть некоторое время N и есть абстрактный разработчик.

Разработчик, получая задачу мыслит примерно следующим образом: "Сейчас я по быстрому запилю новый функционал; выпилю старый и выложу на бой. Все это у меня займет N/4, добавлю N/8 на тестирование, но с учетом различных непредвиденных факторов я заложу 2/3N, плюс оставлю 1/3N на всякий случай". При должном уровне владения предметной областью, ответственного подхода к написанию кода и тестированию все действительно можно было бы реализовать за 2/3N. Возможно иногда все получается и задача успевает завершиться за N. 

Но все же "запилить по быстрому" - это неверный подход, допустимый разве что для небольшой задачи. Попробую объяснить почему. Через оптику разработчика, как я описал выше, задача выглядит так: разработка (самый жирный кусок), тестирование и деплой. Но у реальности немного другая оптика, в свете которой почти всегда рушатся изначальные планы разработчиков. **Основной недостаток реальности в том, что в реальности всегда что-то может пойти не так, особенно с большими задачами.**

### Если что-то пойдет не так. Как разработчику минимизировать риски.

*Если что-то пойдет не так после апгрейда - Способы снизить риски - Проектирование механизмов обратной связи: метрики, логи - Минимизация потерь за счет плавного переключения через механизм тоглеров - О важности развития горизонтальных связей и наличия поддержки нужных людей в нужный момент.*

**Всегда что-то может пойти не так не только в процессе разработки (отклонение от первоначального плана), но и после релиза.** Что-то сломаться может как внутри самой системы, так и в каждой из внешних зависимостей. Причем, если поведение внешних систем от нас совершенно никак не зависит, то уменьшить возможные риски, связанные с отклонениями в подконтрольной системе, можно. 

#### Проектирование механизмов обратной связи

Необходимо заложить вероятность того, что что-то может пойти не так, еще до того как вы приступили к реализации нового функционала. А при разработке системы нужно всегда держать в голове вопрос:

**Что я буду делать, если что-то пойдет не так?**

Это поможет вам правильно определить самые критичные места в системе и спроектировать пути решения возможных проблем.

Мы привыкли к тому, что если что-то идет не так при деплое, то это выявляется практически сразу. Все знают про важность метрик и логов. Мы знаем, что в хорошем продукте, над которым работают "нормальные пацаны" есть метрики на все абсолютно, и любую аномалию тут же выявят. Как только что-то пойдет не так тут же посыплются алерты с описанием причины и вариантами решения. Однако бывают разные системы. Бывает что комбинаций всевозможных параметров так много, что выявить какая из этих комбинаций - симптом проблемы, а какая характеризует нормальную работу, совсем нетривиальная задача. 

_______________________

Представьте (погружение в проблему):

Вы разработчик. В вашей системе проблема, как вы это обнаружите? 

Что вы будете делать, если обнаружите что что-то не так через два дня после релиза? 

Должны ли вы наблюдать за судьбой своей системы после того как вы выкатились или вам следует тут же с головой окунуться в новую задачу? 

Если вы не вы, то кто будет следить за системой после выкатывания, сколько дней? Как минимум нужно найти человека недозагруженного работой. А реально ли это? 

Что-то пошло не так, или вы только предполагаете, что что-то идет не так. Кто вам поможет в этой сложной ситуацию? Вы сами будете писать запросы в базу, искать по логам подтверждение своей гипотезы об аномалиях? 

_______________________

Наверное, только если вы на себе ощутили подобную ситуацию, вы до конца поймете насколько это неприятное положение. Если вы не хотите переживать это снова и снова, продумайте заранее негативные сценарии, продумайте как вы можете сами себе помочь на этапе проектирования, пока у вас еще есть время. Какие метрики вы будете использовать, какие логи смотреть, когда времени у вас уже не будет.

Перед разработкой системы необходимо сразу продумать дашборд/план показателей/метрик/логов, дающих обратную связь, **именно на ваши новые изменения**. Сбор новых метрик вы должны запустить еще на старой системе, чтобы видеть разницу. В данном случае это чем то похоже на TDD, где вы начинаете писать систему с тестов. Практика написания системы с продумывания сбора метрик и логов спасет вас от многих проблем.

Знайте и любите свой продукт. Я считаю, что каждый разработчик должен знать основные "цифры", уметь понимать и читать метрики поддерживаемого продукта. Знать всех основных клиентов продукта, а также особенности их поведения. Скажем у одних клиентов трафик в течение дня может быть распределен одним образом, у других совсем иначе. И одно и тоже распределение некой метрики, может быть приемлемо для одного клиента, но для другого быть признаком присутствия дефекта в системе. И зачастую только человек способен различить эти нюансы..

#### Минимизация потерь за счет плавного переключения через механизм тоглеров и постепенное замещения старого функционала.

Другим способом снизить риски при релизе большого апгрейда является использование тоглеров/переключателей для плавного выкатывания фичи на прод.

Самые очевидные ошибки при апгрейде системы:

1. Создание новой, заново переписанной и лучшей версии; 

2. Реализация переключения типа "вжух" между старой и новой системой - вжух и система после деплоя на продакшен перешла в состояние Б. Однако чаще всего “вжух” превращается в картинку ниже

<span style="display:block;text-align:center">
<img src="/static/vzuh.jpg" width="450px">
<br>Рис. 3 Вжух...
</span>

Конечно использование сплита для "обкатки" новой фичи только на части трафика в какой-то мере помогает протестировать на регресс, но тоже далеко не всегда. Никто не держит на сплите изменения в течение нескольких дней. А цикл полной обкатки может быть завязан на какие то внешние циклы, которые вполне могут иметь длительность несколько дней или даже недель. 

На моей практике самым эффективным способом оказался вариант плавного переключения трафика с использованием переключателей - тоглеров. В отличии от переключения части трафика на сплит-сервер, при котором это делается только для кратковременной обкатки фичи. Суть тоглеров состоит в том что деплой фичи проектируется с возможностью длительной работы системы одновременно в двух режимах: как с новым функционалом, так и без него, а также с возможностью быстрого переключения между этими режимами. (Например, ваши клиенты могут долго согласовывать переключение, но после согласования переключение должно быть произведено по щелчку). Сами тоглеры можно реализовать по разному (все зависит от решаемой задачи и вашей инфраструктуры): через базу данных, переменные окружения, постепенный перевод роутов в nginx на новую api.

Но за все нужно платить, в данном случае, как в советских магазинах, где чтобы купить что-то стоящее нужно было докупить до кучи ненужного, здесь гибкость подается с некоторыми утяжеляющими факторами. Это гирьки, которые все время будут привязаны к вашим ногам, но тем не менее вы должны уметь взлетать с ними:

1. Во время перехода между системами, который может затянуться, предстоит поддержка по сути двух систем (разработка не останавливается), а это: своя логика, свои тесты, свои логи, своя конфигурация и тп. Другими словами все умноженное на 2. В каком то смысле это похоже на версионирование, но это не версионирование, так как здесь не только "морда" (интерфейс( отличается, но и бекенд. Скорее даже наоборот здесь “морда” может оставаться старая, а бекенд поменяться разительно. Поэтому перед добавлением нового функционала хорошо было пересмотреть сбор тех же логов, метрик по старой системе и вынести их в удобном виде на новые мониторы, дашборты. Возможно на этапе подготовки стоит заранее реализовать какие-то специальные задачи на этот счет. 

2. Решение конфликтов новой и старой логики. Скорее всего не получится просто выкатить параллельно новый функционал не задев текущего. Нужно проверить, что не будет деградации, и внести соответствующие доработки и в новой и в старой системе.

Если говорить образно, то я предлагаю вам проводить апгрейд системы, при котором мы не просто строим новый дом, не снося старого, но и живем в обоих, очень постепенно съезжая со старого, день за днем перенося по одной чашке, вешалке, столу. Все это муторно и в обычной жизни это может показаться нерациональным и каким-то неправильным, но, когда вам действительно есть что терять - в этом есть свой смысл.

В каком-то смысле вы не перерабатываете старую систему, а создаете новую. Которая постепенно вымещает старую. 

Запланируйте некоторое время на постаналитику. Задача не заканчивается выкатыванием на продакшен, она заканчивается подтверждением того, что на продакшене все так как ожидается, и на это может потребоваться время.

Панацеи, как говорится, не существует и описанная мною практика переключателей/тогглеров как и любой другой подход не везде и не всегда применима. Но там, где она может быть использована она поможет здорово облегчить вам жизнь.

#### **Люди разные нужны**, **люди разные важны**

Я считаю, что именно разработчик и команда реализующая задачу должны довести ее до конца. Если вы во что-то вложились, то оно становится для вас важным. Вам решать кто будет в этой команде. Может вам следует сразу заманить в нее своего админа, аналитика, техписа, человека из лайфтима, саппорта. Лучше всего везде заиметь своих людей и держать их на связи в течение всего цикла. Привлеките консультацию лайфтима, аналитики и всех служб, которые могут способствовать успеху вашей задачи. Разработчик должен прокидывать свои "щупальца" во все отделы, чтобы информация свободно перемещалась.

Во всех командах где я работал, можно было услышать утверждение что мы элита и на нас "все держится". Но открою секрет, что так считают в любой команде любого отдела. Зайдите к админам, антифроду, лайфтиму, саппорту, менеджерам, тестировщикам, разработчикам и они скажут вам тоже самое. Эта статья взгляд на разработку с точки зрения разработчика, написанная разработчиком, и по этому в ней разработчик занимает центральное место. Но это не значит что одновременно не может быть в центре менеджер, админы, тестировщики или другие люди. Даже наоборот в этом есть свой смысл, когда систему опутывает сеть из разных людей со своими точками роста и своим видением системы - это определенно хорошо. Однако в других отделах люди изначально работают на другой результат, другие задачи. И с точки зрения качества выката нового функционала, приоритет стать локомотивом всего этого стоит все-таки за разработчиком. 

### Заключение

В общем какая из всего мною написанного мораль. Если вы планируете сложный апгрейд системы то:

1. Переписывание системы с нуля - это плохо;

2. Переключение всего трафика сразу на новую системы - плохо;

3. Не продумывание еще на этапе архитектуры каналов организации обратной связи в виде дашбордов на основе логов, метрик, аналитики - плохо;

4. Отсутствие открытой и доступной документации, свободной циркуляции актуальной информации, открытости всех дашбордов с метриками и аналитикой, отсутствие понятного даже непосвященному человеку описания того, что происходит и где, отсутствие сценариев действия в случае каких-то проблем - плохо;

5. Не "заручиться" заранее поддержкой и наличием понимания задачи у нужных людей в лице админов, dba, лайфтима, аналитиков, техписов, саппорта - это тоже плохо.

6. И последнее, не нужно тянуть одеяло на себя и пытаться все сделать в одиночку. Это приводит ко всякой неправильной фигне.